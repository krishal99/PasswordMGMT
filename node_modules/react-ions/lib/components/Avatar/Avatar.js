'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _style = require('./style.scss');

var _style2 = _interopRequireDefault(_style);

var _bind = require('classnames/bind');

var _bind2 = _interopRequireDefault(_bind);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Avatar = function (_React$Component) {
  _inherits(Avatar, _React$Component);

  function Avatar(props) {
    _classCallCheck(this, Avatar);

    var _this = _possibleConstructorReturn(this, (Avatar.__proto__ || Object.getPrototypeOf(Avatar)).call(this, props));

    _this.state = {
      // If image src was passed in, it is not yet loaded
      // Else, if letters were passed in, set loaded to true
      loaded: !_this.props.src
    };
    _this.state = {
      loaded: !!(!_this.props.fadeIn || !_this.props.src)

      /* If the source changes, and fadeIn
       * is set, fade in the new avatar */
    };

    _this.componentWillReceiveProps = function (nextProps) {
      if (nextProps.src !== _this.props.src && _this.props.fadeIn) {
        _this.setState({ loaded: false });
      }
    };

    _this.shouldComponentUpdate = function (nextProps, nextState) {
      return nextProps.letters !== _this.props.letters || nextProps.src !== _this.props.src || nextProps.size !== _this.props.size || nextProps.fadeIn !== _this.props.fadeIn || nextState.loaded !== _this.state.loaded;
    };

    _this.getWrapperStyle = function () {
      return {
        backgroundColor: _this.props.letterBackgroundColor || _this.getBackgroundColor(),
        width: _this.props.size + 'px',
        height: _this.props.size + 'px'
      };
    };

    _this.getBackgroundColor = function () {
      // If no letters passed in, but a src exists
      if (!_this.props.letters && _this.props.src) return 'transparent';

      // If no letters passed in, return a default color
      if (!_this.props.letters) return '#F93943';

      switch (_this.props.letters.charAt(0).toLowerCase()) {
        case 'a':
        case 'k':
        case 'u':
          return '#F93943';
        case 'b':
        case 'l':
        case 'v':
          return '#796DE8';
        case 'c':
        case 'm':
        case 'w':
          return '#6E3FAF';
        case 'd':
        case 'n':
        case 'x':
          return '#28D397';
        case 'e':
        case 'o':
        case 'y':
          return '#ED7C5A';
        case 'f':
        case 'p':
        case 'z':
          return '#F93983';
        case 'g':
        case 'q':
          return '#F9B339';
        case 'h':
        case 'r':
          return '#6BE2F9';
        case 'i':
        case 's':
          return '#AAE667';
        case 'j':
        case 't':
          return '#ED7BE9';
        default:
          return '#F93943';
      }
    };

    _this.getTextStyle = function () {
      return {
        fontSize: +_this.props.size * 0.6 + 'px'
      };
    };

    _this.handleLoad = function () {
      _this.setState({ loaded: true });
    };

    _this.loadAvatar = function () {
      if (_this.props.src) {
        return _react2.default.createElement('img', { src: _this.props.src, onLoad: _this.handleLoad, alt: _this.props.alt, height: _this.props.size });
      } else if (_this.props.letters) {
        return _react2.default.createElement(
          'div',
          { style: _this.getWrapperStyle() },
          _react2.default.createElement(
            'span',
            { style: _this.getTextStyle() },
            _this.props.letters.length <= 2 ? _this.props.letters : _this.props.letters.substr(0, 2)
          )
        );
      }
    };

    return _this;
  }

  /* If fadeIn is set to false,
   * or if it's a letter-based avatar,
   * set loaded to true, so it won't fade in */


  _createClass(Avatar, [{
    key: 'render',
    value: function render() {
      var cx = _bind2.default.bind(_style2.default);
      var avatarClasses = cx(_style2.default['avatar-wrapper'], this.state.loaded ? 'loaded' : null, this.props.optClass);

      return _react2.default.createElement(
        'div',
        { className: avatarClasses, style: this.props.size ? this.getWrapperStyle() : null },
        this.loadAvatar()
      );
    }
  }]);

  return Avatar;
}(_react2.default.Component);

Avatar.propTypes = {
  /**
   * Optional source of the image to load.
   */
  src: _propTypes2.default.string,
  /**
   * Optional letters to display in lieu of an image.
   */
  letters: _propTypes2.default.string,
  /**
   * Optional background for the letters.
   */
  letterBackgroundColor: _propTypes2.default.string,
  /**
   * Optional alt text for the image
   */
  alt: _propTypes2.default.string,
  /**
   * Optional size to constrain the image (only supports square images)
   */
  size: _propTypes2.default.string,
  /**
   * Optional CSS class to pass to the badge.
   */
  optClass: _propTypes2.default.string,
  /**
   * Option to turn the opacity fade off (defaults to true)
   */
  fadeIn: _propTypes2.default.bool
};
Avatar.defaultProps = {
  fadeIn: true };
exports.default = Avatar;